# 应用预测


## 1.问题：DataType of Paddle Op mul must be the same.

+ 问题描述：使用PaddlePaddle构建模型，模型在训练过程中是正常的，但进行预测时，报`DataType of Paddle Op mul must be the same.`

+ 报错输出：

```
Traceback (most recent call last):
  File "/Users/ayuliao/Desktop/Paddle/Paddlecode/code1.py", line 119, in <module>
    results = inferencer.infer({'mm': test_x})
  File "/Users/ayuliao/anaconda3/envs/paddle/lib/python3.5/site-packages/paddle/fluid/contrib/inferencer.py", line 104, in infer
    return_numpy=return_numpy)
  File "/Users/ayuliao/anaconda3/envs/paddle/lib/python3.5/site-packages/paddle/fluid/executor.py", line 470, in run
    self.executor.run(program.desc, scope, 0, True, True)
paddle.fluid.core.EnforceNotMet: DataType of Paddle Op mul must be the same. Get mm(6) != fc_0.w_0(5) at [/Users/paddle/minqiyang/Paddle/paddle/fluid/framework/operator.cc:847]
PaddlePaddle Call Stacks: 
0          0x10d81da68p paddle::platform::EnforceNotMet::EnforceNotMet(std::exception_ptr, char const*, int) + 760
1          0x10e647a10p paddle::framework::OperatorWithKernel::IndicateDataType(paddle::framework::ExecutionContext const&) const + 864
2          0x10e647aacp paddle::framework::OperatorWithKernel::GetExpectedKernelType(paddle::framework::ExecutionContext const&) const + 44
3          0x10e646099p paddle::framework::OperatorWithKernel::RunImpl(paddle::framework::Scope const&, boost::variant<paddle::platform::CUDAPlace, paddle::platform::CPUPlace, paddle::platform::CUDAPinnedPlace, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_> const&) const + 265
4          0x10e642141p paddle::framework::OperatorBase::Run(paddle::framework::Scope const&, boost::variant<paddle::platform::CUDAPlace, paddle::platform::CPUPlace, paddle::platform::CUDAPinnedPlace, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_> const&) + 577
5          0x10d8eb3a6p paddle::framework::Executor::RunPreparedContext(paddle::framework::ExecutorPrepareContext*, paddle::framework::Scope*, bool, bool, bool) + 390
6          0x10d8eadd3p paddle::framework::Executor::Run(paddle::framework::ProgramDesc const&, paddle::framework::Scope*, int, bool, bool) + 163
7          0x10d851837p void pybind11::cpp_function::initialize<paddle::pybind::pybind11_init()::$_64, void, paddle::framework::Executor&, paddle::framework::ProgramDesc const&, paddle::framework::Scope*, int, bool, bool, pybind11::name, pybind11::is_method, pybind11::sibling>(paddle::pybind::pybind11_init()::$_64&&, void (*)(paddle::framework::Executor&, paddle::framework::ProgramDesc const&, paddle::framework::Scope*, int, bool, bool), pybind11::name const&, pybind11::is_method const&, pybind11::sibling const&)::'lambda'(pybind11::detail::function_call&)::__invoke(pybind11::detail::function_call&) + 135
8          0x10d8283aap pybind11::cpp_function::dispatcher(_object*, _object*, _object*) + 5786
9          0x10091c59fp PyCFunction_Call + 127
10         0x1009e77e7p PyEval_EvalFrameEx + 33207
11         0x1009ddfafp _PyEval_EvalCodeWithName + 335
12         0x1009e42a7p PyEval_EvalFrameEx + 19575
13         0x1009ddfafp _PyEval_EvalCodeWithName + 335
14         0x1009e42a7p PyEval_EvalFrameEx + 19575
15         0x1009ddfafp _PyEval_EvalCodeWithName + 335
16         0x100a30758p PyRun_FileExFlags + 248
17         0x100a2feeep PyRun_SimpleFileExFlags + 382
18         0x100a54d86p Py_Main + 3622
19         0x100896861p main + 497
20      0x7fff5dffe015p start + 1
21                 0x2p
```

+ 问题复现：

```python

```
# 定义一个预测网络来做预测
def inference_program():
    mm = fluid.layers.data(name='mm', shape=[13], dtype='float64')
    y_predict = fluid.layers.fc(input=mm, size=1, act=None)
    return y_predict

# Inferencer 要输入预测程序，与模型的路径，预测器其实就是读入此前训练好的模型，再使用预测程序跑一遍
inferencer = Inferencer(
    infer_func = inference_program, param_path = params_dirname, place=place
)
```

+ 问题解决：

导入模型文件，其中的输入层数据类型要与预期网络的数据类型相同
